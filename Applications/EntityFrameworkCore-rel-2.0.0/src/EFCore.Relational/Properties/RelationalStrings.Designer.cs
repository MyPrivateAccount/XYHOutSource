// <auto-generated />

using System;
using System.Reflection;
using System.Resources;
using JetBrains.Annotations;
using Microsoft.EntityFrameworkCore.Diagnostics;
using Microsoft.Extensions.Logging;

namespace Microsoft.EntityFrameworkCore.Internal
{
    /// <summary>
    ///		This API supports the Entity Framework Core infrastructure and is not intended to be used
    ///     directly from your code. This API may change or be removed in future releases.
    /// </summary>
    public static class RelationalStrings
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager("Microsoft.EntityFrameworkCore.Properties.RelationalStrings", typeof(RelationalStrings).GetTypeInfo().Assembly);

        /// <summary>
        ///     Cannot save changes for an entity in state '{entityState}'.
        /// </summary>
        public static string ModificationCommandInvalidEntityState([CanBeNull] object entityState)
            => string.Format(
                GetString("ModificationCommandInvalidEntityState", nameof(entityState)),
                entityState);

        /// <summary>
        ///     Database operation expected to affect {expectedRows} row(s) but actually affected {actualRows} row(s). Data may have been modified or deleted since entities were loaded. See http://go.microsoft.com/fwlink/?LinkId=527962 for information on understanding and handling optimistic concurrency exceptions.
        /// </summary>
        public static string UpdateConcurrencyException([CanBeNull] object expectedRows, [CanBeNull] object actualRows)
            => string.Format(
                GetString("UpdateConcurrencyException", nameof(expectedRows), nameof(actualRows)),
                expectedRows, actualRows);

        /// <summary>
        ///     Multiple relational database provider configurations found. A context can only be configured to use a single database provider.
        /// </summary>
        public static string MultipleProvidersConfigured
            => GetString("MultipleProvidersConfigured");

        /// <summary>
        ///     No relational database providers are configured. Configure a database provider using OnConfiguring or by creating an ImmutableDbContextOptions with a database provider configured and passing it to the context.
        /// </summary>
        public static string NoProviderConfigured
            => GetString("NoProviderConfigured");

        /// <summary>
        ///     Both an existing DbConnection and a connection string have been configured. When an existing DbConnection is used the connection string must be set on that connection.
        /// </summary>
        public static string ConnectionAndConnectionString
            => GetString("ConnectionAndConnectionString");

        /// <summary>
        ///     A relational store has been configured without specifying either the DbConnection or connection string to use.
        /// </summary>
        public static string NoConnectionOrConnectionString
            => GetString("NoConnectionOrConnectionString");

        /// <summary>
        ///     A named connection string was used, but the name '{name}' was not found in the application's configuration. Note that named connection strings are only supported when using 'IConfiguration' and a service provider, such as in a typical ASP.NET Core application. See https://go.microsoft.com/fwlink/?linkid=850912 for more information.
        /// </summary>
        public static string NamedConnectionStringNotFound([CanBeNull] object name)
            => string.Format(
                GetString("NamedConnectionStringNotFound", nameof(name)),
                name);

        /// <summary>
        ///     No mapping to a relational type can be found for the CLR type '{clrType}'.
        /// </summary>
        public static string UnsupportedType([CanBeNull] object clrType)
            => string.Format(
                GetString("UnsupportedType", nameof(clrType)),
                clrType);

        /// <summary>
        ///     Relational-specific methods can only be used when the context is using a relational database provider.
        /// </summary>
        public static string RelationalNotInUse
            => GetString("RelationalNotInUse");

        /// <summary>
        ///     The 'bool' property '{property}' on entity type '{entityType}' is configured with a database-generated default. This default will always be used when the property has the value 'false', since this is the CLR default for the 'bool' type. Consider using the nullable 'bool?' type instead so that the default will only be used when the property value is 'null'.
        /// </summary>
        public static readonly EventDefinition<string, string> LogBoolWithDefaultWarning
            = new EventDefinition<string, string>(
                RelationalEventId.BoolWithDefaultWarning,
                LogLevel.Warning,
                LoggerMessage.Define<string, string>(
                    LogLevel.Warning,
                    RelationalEventId.BoolWithDefaultWarning,
                    _resourceManager.GetString("LogBoolWithDefaultWarning")));

        /// <summary>
        ///     An error occurred while updating the entries. See the inner exception for details.
        /// </summary>
        public static string UpdateStoreException
            => GetString("UpdateStoreException");

        /// <summary>
        ///     The connection is already in a transaction and cannot participate in another transaction.
        /// </summary>
        public static string TransactionAlreadyStarted
            => GetString("TransactionAlreadyStarted");

        /// <summary>
        ///     The specified transaction is not associated with the current connection. Only transactions associated with the current connection may be used.
        /// </summary>
        public static string TransactionAssociatedWithDifferentConnection
            => GetString("TransactionAssociatedWithDifferentConnection");

        /// <summary>
        ///     Opening connection to database '{database}' on server '{server}'.
        /// </summary>
        public static readonly EventDefinition<string, string> LogRelationalLoggerOpeningConnection
            = new EventDefinition<string, string>(
                RelationalEventId.ConnectionOpening,
                LogLevel.Debug,
                LoggerMessage.Define<string, string>(
                    LogLevel.Debug,
                    RelationalEventId.ConnectionOpening,
                    _resourceManager.GetString("LogRelationalLoggerOpeningConnection")));

        /// <summary>
        ///     Opened connection to database '{database}' on server '{server}'.
        /// </summary>
        public static readonly EventDefinition<string, string> LogRelationalLoggerOpenedConnection
            = new EventDefinition<string, string>(
                RelationalEventId.ConnectionOpened,
                LogLevel.Debug,
                LoggerMessage.Define<string, string>(
                    LogLevel.Debug,
                    RelationalEventId.ConnectionOpened,
                    _resourceManager.GetString("LogRelationalLoggerOpenedConnection")));

        /// <summary>
        ///     Closing connection to database '{database}' on server '{server}'.
        /// </summary>
        public static readonly EventDefinition<string, string> LogRelationalLoggerClosingConnection
            = new EventDefinition<string, string>(
                RelationalEventId.ConnectionClosing,
                LogLevel.Debug,
                LoggerMessage.Define<string, string>(
                    LogLevel.Debug,
                    RelationalEventId.ConnectionClosing,
                    _resourceManager.GetString("LogRelationalLoggerClosingConnection")));

        /// <summary>
        ///     Closed connection to database '{database}' on server '{server}'.
        /// </summary>
        public static readonly EventDefinition<string, string> LogRelationalLoggerClosedConnection
            = new EventDefinition<string, string>(
                RelationalEventId.ConnectionClosed,
                LogLevel.Debug,
                LoggerMessage.Define<string, string>(
                    LogLevel.Debug,
                    RelationalEventId.ConnectionClosed,
                    _resourceManager.GetString("LogRelationalLoggerClosedConnection")));

        /// <summary>
        ///     An error occurred using the connection to database '{database}' on server '{server}'.
        /// </summary>
        public static readonly EventDefinition<string, string> LogRelationalLoggerConnectionError
            = new EventDefinition<string, string>(
                RelationalEventId.ConnectionError,
                LogLevel.Error,
                LoggerMessage.Define<string, string>(
                    LogLevel.Error,
                    RelationalEventId.ConnectionError,
                    _resourceManager.GetString("LogRelationalLoggerConnectionError")));

        /// <summary>
        ///     Beginning transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static readonly EventDefinition<string> LogRelationalLoggerBeginningTransaction
            = new EventDefinition<string>(
                RelationalEventId.TransactionStarted,
                LogLevel.Debug,
                LoggerMessage.Define<string>(
                    LogLevel.Debug,
                    RelationalEventId.TransactionStarted,
                    _resourceManager.GetString("LogRelationalLoggerBeginningTransaction")));

        /// <summary>
        ///     Using an existing transaction with isolation level '{isolationLevel}'.
        /// </summary>
        public static readonly EventDefinition<string> LogRelationalLoggerUsingTransaction
            = new EventDefinition<string>(
                RelationalEventId.TransactionUsed,
                LogLevel.Debug,
                LoggerMessage.Define<string>(
                    LogLevel.Debug,
                    RelationalEventId.TransactionUsed,
                    _resourceManager.GetString("LogRelationalLoggerUsingTransaction")));

        /// <summary>
        ///     Committing transaction.
        /// </summary>
        public static readonly EventDefinition LogRelationalLoggerCommittingTransaction
            = new EventDefinition(
                RelationalEventId.TransactionCommitted,
                LogLevel.Debug,
                LoggerMessage.Define(
                    LogLevel.Debug,
                    RelationalEventId.TransactionCommitted,
                    _resourceManager.GetString("LogRelationalLoggerCommittingTransaction")));

        /// <summary>
        ///     Rolling back transaction.
        /// </summary>
        public static readonly EventDefinition LogRelationalLoggerRollingbackTransaction
            = new EventDefinition(
                RelationalEventId.TransactionRolledBack,
                LogLevel.Debug,
                LoggerMessage.Define(
                    LogLevel.Debug,
                    RelationalEventId.TransactionRolledBack,
                    _resourceManager.GetString("LogRelationalLoggerRollingbackTransaction")));

        /// <summary>
        ///     Disposing transaction.
        /// </summary>
        public static readonly EventDefinition LogRelationalLoggerDisposingTransaction
            = new EventDefinition(
                RelationalEventId.TransactionDisposed,
                LogLevel.Debug,
                LoggerMessage.Define(
                    LogLevel.Debug,
                    RelationalEventId.TransactionDisposed,
                    _resourceManager.GetString("LogRelationalLoggerDisposingTransaction")));

        /// <summary>
        ///     An error occurred using a transaction.
        /// </summary>
        public static readonly EventDefinition LogRelationalLoggerTransactionError
            = new EventDefinition(
                RelationalEventId.TransactionError,
                LogLevel.Error,
                LoggerMessage.Define(
                    LogLevel.Error,
                    RelationalEventId.TransactionError,
                    _resourceManager.GetString("LogRelationalLoggerTransactionError")));

        /// <summary>
        ///     A data reader was disposed.
        /// </summary>
        public static readonly EventDefinition LogDisposingDataReader
            = new EventDefinition(
                RelationalEventId.DataReaderDisposing,
                LogLevel.Debug,
                LoggerMessage.Define(
                    LogLevel.Debug,
                    RelationalEventId.DataReaderDisposing,
                    _resourceManager.GetString("LogDisposingDataReader")));

        /// <summary>
        ///     Invalid type for sequence. Valid types are 'Int64' (the default), 'Int32', 'Int16', and 'Byte'.
        /// </summary>
        public static string BadSequenceType
            => GetString("BadSequenceType");

        /// <summary>
        ///     Unable to deserialize sequence from model metadata. See inner exception for details.
        /// </summary>
        public static string BadSequenceString
            => GetString("BadSequenceString");

        /// <summary>
        ///     The migration '{migrationName}' was not found.
        /// </summary>
        public static string MigrationNotFound([CanBeNull] object migrationName)
            => string.Format(
                GetString("MigrationNotFound", nameof(migrationName)),
                migrationName);

        /// <summary>
        ///     The current migration SQL generator '{sqlGeneratorType}' is unable to generate SQL for operations of type '{operationType}'.
        /// </summary>
        public static string UnknownOperation([CanBeNull] object sqlGeneratorType, [CanBeNull] object operationType)
            => string.Format(
                GetString("UnknownOperation", nameof(sqlGeneratorType), nameof(operationType)),
                sqlGeneratorType, operationType);

        /// <summary>
        ///     The specified CommandTimeout value is not valid. It must be a positive number.
        /// </summary>
        public static string InvalidCommandTimeout
            => GetString("InvalidCommandTimeout");

        /// <summary>
        ///     The specified MaxBatchSize value is not valid. It must be a positive number.
        /// </summary>
        public static string InvalidMaxBatchSize
            => GetString("InvalidMaxBatchSize");

        /// <summary>
        ///     Unable to materialize entity of type '{entityType}'. No discriminators were matched.
        /// </summary>
        public static string UnableToDiscriminate([CanBeNull] object entityType)
            => string.Format(
                GetString("UnableToDiscriminate", nameof(entityType)),
                entityType);

        /// <summary>
        ///     A discriminator property cannot be set for the entity type '{entityType}' because it is not the root of an inheritance hierarchy.
        /// </summary>
        public static string DiscriminatorPropertyMustBeOnRoot([CanBeNull] object entityType)
            => string.Format(
                GetString("DiscriminatorPropertyMustBeOnRoot", nameof(entityType)),
                entityType);

        /// <summary>
        ///     Unable to set property '{property}' as a discriminator for entity type '{entityType}' because it is not a property of '{entityType}'.
        /// </summary>
        public static string DiscriminatorPropertyNotFound([CanBeNull] object property, [CanBeNull] object entityType)
            => string.Format(
                GetString("DiscriminatorPropertyNotFound", nameof(property), nameof(entityType)),
                property, entityType);

        /// <summary>
        ///     An ambient transaction has been detected. Entity Framework Core does not support ambient transactions. See http://go.microsoft.com/fwlink/?LinkId=800142
        /// </summary>
        public static readonly EventDefinition LogAmbientTransaction
            = new EventDefinition(
                RelationalEventId.AmbientTransactionWarning,
                LogLevel.Warning,
                LoggerMessage.Define(
                    LogLevel.Warning,
                    RelationalEventId.AmbientTransactionWarning,
                    _resourceManager.GetString("LogAmbientTransaction")));

        /// <summary>
        ///     Possible unintended use of method Equals(object) for arguments of different types in expression '{expression}'. This comparison will always return 'false'.
        /// </summary>
        public static readonly EventDefinition<object> LogPossibleUnintendedUseOfEquals
            = new EventDefinition<object>(
                RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning,
                LogLevel.Warning,
                LoggerMessage.Define<object>(
                    LogLevel.Warning,
                    RelationalEventId.QueryPossibleUnintendedUseOfEqualsWarning,
                    _resourceManager.GetString("LogPossibleUnintendedUseOfEquals")));

        /// <summary>
        ///     Possible unintended use of a potentially throwing aggregate method (Min, Max, Average) in a subquery. Client evaluation will be used and operator will throw if no data exists. Changing the subquery result type to a nullable type will allow full translation.
        /// </summary>
        public static readonly EventDefinition LogQueryPossibleExceptionWithAggregateOperator
            = new EventDefinition(
                RelationalEventId.QueryPossibleExceptionWithAggregateOperator,
                LogLevel.Warning,
                LoggerMessage.Define(
                    LogLevel.Warning,
                    RelationalEventId.QueryPossibleExceptionWithAggregateOperator,
                    _resourceManager.GetString("LogQueryPossibleExceptionWithAggregateOperator")));

        /// <summary>
        ///     The Include operation is not supported when calling a stored procedure.
        /// </summary>
        public static string StoredProcedureIncludeNotSupported
            => GetString("StoredProcedureIncludeNotSupported");

        /// <summary>
        ///     Generating down script for migration '{migration}'.
        /// </summary>
        public static readonly EventDefinition<string> LogGeneratingDown
            = new EventDefinition<string>(
                RelationalEventId.MigrationGeneratingDownScript,
                LogLevel.Debug,
                LoggerMessage.Define<string>(
                    LogLevel.Debug,
                    RelationalEventId.MigrationGeneratingDownScript,
                    _resourceManager.GetString("LogGeneratingDown")));

        /// <summary>
        ///     Generating up script for migration '{migration}'.
        /// </summary>
        public static readonly EventDefinition<string> LogGeneratingUp
            = new EventDefinition<string>(
                RelationalEventId.MigrationGeneratingUpScript,
                LogLevel.Debug,
                LoggerMessage.Define<string>(
                    LogLevel.Debug,
                    RelationalEventId.MigrationGeneratingUpScript,
                    _resourceManager.GetString("LogGeneratingUp")));

        /// <summary>
        ///     Applying migration '{migration}'.
        /// </summary>
        public static readonly EventDefinition<string> LogApplyingMigration
            = new EventDefinition<string>(
                RelationalEventId.MigrationApplying,
                LogLevel.Information,
                LoggerMessage.Define<string>(
                    LogLevel.Information,
                    RelationalEventId.MigrationApplying,
                    _resourceManager.GetString("LogApplyingMigration")));

        /// <summary>
        ///     Reverting migration '{migration}'.
        /// </summary>
        public static readonly EventDefinition<string> LogRevertingMigration
            = new EventDefinition<string>(
                RelationalEventId.MigrationReverting,
                LogLevel.Information,
                LoggerMessage.Define<string>(
                    LogLevel.Information,
                    RelationalEventId.MigrationReverting,
                    _resourceManager.GetString("LogRevertingMigration")));

        /// <summary>
        ///     Migrating using database '{database}' on server '{dataSource}'.
        /// </summary>
        public static readonly EventDefinition<string, string> LogMigrating
            = new EventDefinition<string, string>(
                RelationalEventId.MigrateUsingConnection,
                LogLevel.Debug,
                LoggerMessage.Define<string, string>(
                    LogLevel.Debug,
                    RelationalEventId.MigrateUsingConnection,
                    _resourceManager.GetString("LogMigrating")));

        /// <summary>
        ///     No migrations were applied. The database is already up to date.
        /// </summary>
        public static readonly EventDefinition LogNoMigrationsApplied
            = new EventDefinition(
                RelationalEventId.MigrationsNotApplied,
                LogLevel.Information,
                LoggerMessage.Define(
                    LogLevel.Information,
                    RelationalEventId.MigrationsNotApplied,
                    _resourceManager.GetString("LogNoMigrationsApplied")));

        /// <summary>
        ///     No migrations were found in assembly '{migrationsAssembly}'.
        /// </summary>
        public static readonly EventDefinition<string> LogNoMigrationsFound
            = new EventDefinition<string>(
                RelationalEventId.MigrationsNotFound,
                LogLevel.Debug,
                LoggerMessage.Define<string>(
                    LogLevel.Debug,
                    RelationalEventId.MigrationsNotFound,
                    _resourceManager.GetString("LogNoMigrationsFound")));

        /// <summary>
        ///     The required column '{column}' was not present in the results of a 'FromSql' operation.
        /// </summary>
        public static string FromSqlMissingColumn([CanBeNull] object column)
            => string.Format(
                GetString("FromSqlMissingColumn", nameof(column)),
                column);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and the name '{keyName}' of the primary key {primaryKey} does not match the name '{otherName}' of the primary key {otherPrimaryKey}.
        /// </summary>
        public static string IncompatibleTableKeyNameMismatch([CanBeNull] object table, [CanBeNull] object entityType, [CanBeNull] object otherEntityType, [CanBeNull] object keyName, [CanBeNull] object primaryKey, [CanBeNull] object otherName, [CanBeNull] object otherPrimaryKey)
            => string.Format(
                GetString("IncompatibleTableKeyNameMismatch", nameof(table), nameof(entityType), nameof(otherEntityType), nameof(keyName), nameof(primaryKey), nameof(otherName), nameof(otherPrimaryKey)),
                table, entityType, otherEntityType, keyName, primaryKey, otherName, otherPrimaryKey);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{entityType}' since it is being used for entity type '{otherEntityType}' and there is no relationship between the primary key {primaryKey} and the primary key {otherPrimaryKey}.
        /// </summary>
        public static string IncompatibleTableNoRelationship([CanBeNull] object table, [CanBeNull] object entityType, [CanBeNull] object otherEntityType, [CanBeNull] object primaryKey, [CanBeNull] object otherPrimaryKey)
            => string.Format(
                GetString("IncompatibleTableNoRelationship", nameof(table), nameof(entityType), nameof(otherEntityType), nameof(primaryKey), nameof(otherPrimaryKey)),
                table, entityType, otherEntityType, primaryKey, otherPrimaryKey);

        /// <summary>
        ///     Cannot use table '{table}' for entity type '{dependentType}' since it has a relation ship to a derived entity type '{principalType}'. Either point the relationship to the base type '{rootType}' or map '{dependentType}' to a different table.
        /// </summary>
        public static string IncompatibleTableDerivedPrincipal([CanBeNull] object table, [CanBeNull] object dependentType, [CanBeNull] object principalType, [CanBeNull] object rootType)
            => string.Format(
                GetString("IncompatibleTableDerivedPrincipal", nameof(table), nameof(dependentType), nameof(principalType), nameof(rootType)),
                table, dependentType, principalType, rootType);

        /// <summary>
        ///     Property '{property}' on entity type '{entityType}' is part of a primary or alternate key but has a constant default value set. Constant default values are not useful for primary or alternate keys since these properties must always have non-null unqiue values.
        /// </summary>
        public static readonly EventDefinition<string, string> LogKeyHasDefaultValue
            = new EventDefinition<string, string>(
                RelationalEventId.ModelValidationKeyDefaultValueWarning,
                LogLevel.Warning,
                LoggerMessage.Define<string, string>(
                    LogLevel.Warning,
                    RelationalEventId.ModelValidationKeyDefaultValueWarning,
                    _resourceManager.GetString("LogKeyHasDefaultValue")));

        /// <summary>
        ///     Cannot configure the discriminator value for entity type '{entityType}' because it doesn't derive from '{rootEntityType}'.
        /// </summary>
        public static string DiscriminatorEntityTypeNotDerived([CanBeNull] object entityType, [CanBeNull] object rootEntityType)
            => string.Format(
                GetString("DiscriminatorEntityTypeNotDerived", nameof(entityType), nameof(rootEntityType)),
                entityType, rootEntityType);

        /// <summary>
        ///     Cannot set discriminator value '{value}' for discriminator property '{discriminator}' because it is not assignable to property of type '{discriminatorType}'.
        /// </summary>
        public static string DiscriminatorValueIncompatible([CanBeNull] object value, [CanBeNull] object discriminator, [CanBeNull] object discriminatorType)
            => string.Format(
                GetString("DiscriminatorValueIncompatible", nameof(value), nameof(discriminator), nameof(discriminatorType)),
                value, discriminator, discriminatorType);

        /// <summary>
        ///     Cannot set discriminator value for entity type '{entityType}' because the root entity type '{rootEntityType}' doesn't have a discriminator property set.
        /// </summary>
        public static string NoDiscriminatorForValue([CanBeNull] object entityType, [CanBeNull] object rootEntityType)
            => string.Format(
                GetString("NoDiscriminatorForValue", nameof(entityType), nameof(rootEntityType)),
                entityType, rootEntityType);

        /// <summary>
        ///     The entity type '{entityType}' is part of a hierarchy, but does not have a discriminator property configured.
        /// </summary>
        public static string NoDiscriminatorProperty([CanBeNull] object entityType)
            => string.Format(
                GetString("NoDiscriminatorProperty", nameof(entityType)),
                entityType);

        /// <summary>
        ///     The entity type '{entityType}' is part of a hierarchy, but does not have a discriminator value configured.
        /// </summary>
        public static string NoDiscriminatorValue([CanBeNull] object entityType)
            => string.Format(
                GetString("NoDiscriminatorValue", nameof(entityType)),
                entityType);

        /// <summary>
        ///     The LINQ expression '{expression}' could not be translated and will be evaluated locally.
        /// </summary>
        public static readonly EventDefinition<object> LogClientEvalWarning
            = new EventDefinition<object>(
                RelationalEventId.QueryClientEvaluationWarning,
                LogLevel.Warning,
                LoggerMessage.Define<object>(
                    LogLevel.Warning,
                    RelationalEventId.QueryClientEvaluationWarning,
                    _resourceManager.GetString("LogClientEvalWarning")));

        /// <summary>
        ///     No value provided for required parameter '{parameter}'.
        /// </summary>
        public static string MissingParameterValue([CanBeNull] object parameter)
            => string.Format(
                GetString("MissingParameterValue", nameof(parameter)),
                parameter);

        /// <summary>
        ///     Cannot use the value provided for parameter '{parameter}' because it isn't assignable to type object[].
        /// </summary>
        public static string ParameterNotObjectArray([CanBeNull] object parameter)
            => string.Format(
                GetString("ParameterNotObjectArray", nameof(parameter)),
                parameter);

        /// <summary>
        ///     Executing DbCommand [Parameters=[{parameters}], CommandType='{commandType}', CommandTimeout='{commandTimeout}']{newLine}{commandText}
        /// </summary>
        public static readonly EventDefinition<string, System.Data.CommandType, int, string, string> LogRelationalLoggerExecutingCommand
            = new EventDefinition<string, System.Data.CommandType, int, string, string>(
                RelationalEventId.CommandExecuting,
                LogLevel.Debug,
                LoggerMessage.Define<string, System.Data.CommandType, int, string, string>(
                    LogLevel.Debug,
                    RelationalEventId.CommandExecuting,
                    _resourceManager.GetString("LogRelationalLoggerExecutingCommand")));

        /// <summary>
        ///     Executed DbCommand ({elapsed}ms) [Parameters=[{parameters}], CommandType='{commandType}', CommandTimeout='{commandTimeout}']{newLine}{commandText}
        /// </summary>
        public static readonly EventDefinition<string, string, System.Data.CommandType, int, string, string> LogRelationalLoggerExecutedCommand
            = new EventDefinition<string, string, System.Data.CommandType, int, string, string>(
                RelationalEventId.CommandExecuted,
                LogLevel.Information,
                LoggerMessage.Define<string, string, System.Data.CommandType, int, string, string>(
                    LogLevel.Information,
                    RelationalEventId.CommandExecuted,
                    _resourceManager.GetString("LogRelationalLoggerExecutedCommand")));

        /// <summary>
        ///     Failed executing DbCommand ({elapsed}ms) [Parameters=[{parameters}], CommandType='{commandType}', CommandTimeout='{commandTimeout}']{newLine}{commandText}
        /// </summary>
        public static readonly EventDefinition<string, string, System.Data.CommandType, int, string, string> LogRelationalLoggerCommandFailed
            = new EventDefinition<string, string, System.Data.CommandType, int, string, string>(
                RelationalEventId.CommandError,
                LogLevel.Error,
                LoggerMessage.Define<string, string, System.Data.CommandType, int, string, string>(
                    LogLevel.Error,
                    RelationalEventId.CommandError,
                    _resourceManager.GetString("LogRelationalLoggerCommandFailed")));

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured to use different data types ('{dataType1}' and '{dataType2}').
        /// </summary>
        public static string DuplicateColumnNameDataTypeMismatch([CanBeNull] object entityType1, [CanBeNull] object property1, [CanBeNull] object entityType2, [CanBeNull] object property2, [CanBeNull] object columnName, [CanBeNull] object table, [CanBeNull] object dataType1, [CanBeNull] object dataType2)
            => string.Format(
                GetString("DuplicateColumnNameDataTypeMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(dataType1), nameof(dataType2)),
                entityType1, property1, entityType2, property2, columnName, table, dataType1, dataType2);

        /// <summary>
        ///     The connection does not have any active transactions.
        /// </summary>
        public static string NoActiveTransaction
            => GetString("NoActiveTransaction");

        /// <summary>
        ///     An instance of entity type '{firstEntityType}' is marked as '{firstState}', but an instance of entity type '{secondEntityType}' is marked as '{secondState}' and both are mapped to the same row. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the key values.
        /// </summary>
        public static string ConflictingRowUpdateTypes([CanBeNull] object firstEntityType, [CanBeNull] object firstState, [CanBeNull] object secondEntityType, [CanBeNull] object secondState)
            => string.Format(
                GetString("ConflictingRowUpdateTypes", nameof(firstEntityType), nameof(firstState), nameof(secondEntityType), nameof(secondState)),
                firstEntityType, firstState, secondEntityType, secondState);

        /// <summary>
        ///     The instance of entity type '{firstEntityType}' with the key value '{firstKeyValue}' is marked as '{firstState}', but the instance of entity type '{secondEntityType}' with the key value '{secondKeyValue}' is marked as '{secondState}' and both are mapped to the same row.
        /// </summary>
        public static string ConflictingRowUpdateTypesSensitive([CanBeNull] object firstEntityType, [CanBeNull] object firstKeyValue, [CanBeNull] object firstState, [CanBeNull] object secondEntityType, [CanBeNull] object secondKeyValue, [CanBeNull] object secondState)
            => string.Format(
                GetString("ConflictingRowUpdateTypesSensitive", nameof(firstEntityType), nameof(firstKeyValue), nameof(firstState), nameof(secondEntityType), nameof(secondKeyValue), nameof(secondState)),
                firstEntityType, firstKeyValue, firstState, secondEntityType, secondKeyValue, secondState);

        /// <summary>
        ///     An instance of entity type '{firstEntityType}' and an instance of entity type '{secondEntityType}' are mapped to the same row, but have different property values for the properties {firstProperties} and {secondProperties} mapped to {columns}. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the conflicting values.
        /// </summary>
        public static string ConflictingRowValues([CanBeNull] object firstEntityType, [CanBeNull] object secondEntityType, [CanBeNull] object firstProperties, [CanBeNull] object secondProperties, [CanBeNull] object columns)
            => string.Format(
                GetString("ConflictingRowValues", nameof(firstEntityType), nameof(secondEntityType), nameof(firstProperties), nameof(secondProperties), nameof(columns)),
                firstEntityType, secondEntityType, firstProperties, secondProperties, columns);

        /// <summary>
        ///     The instance of entity type '{firstEntityType}' and the instance of entity type '{secondEntityType}' are mapped to the same row with the key value '{keyValue}', but have different property values '{firstConflictingValues}' and '{secondConflictingValues}' mapped to {columns}.
        /// </summary>
        public static string ConflictingRowValuesSensitive([CanBeNull] object firstEntityType, [CanBeNull] object secondEntityType, [CanBeNull] object keyValue, [CanBeNull] object firstConflictingValues, [CanBeNull] object secondConflictingValues, [CanBeNull] object columns)
            => string.Format(
                GetString("ConflictingRowValuesSensitive", nameof(firstEntityType), nameof(secondEntityType), nameof(keyValue), nameof(firstConflictingValues), nameof(secondConflictingValues), nameof(columns)),
                firstEntityType, secondEntityType, keyValue, firstConflictingValues, secondConflictingValues, columns);

        /// <summary>
        ///     An instance of entity type '{firstEntityType}' and an instance of entity type '{secondEntityType}' are mapped to the same row, but have different original property values for the properties {firstProperties} and {secondProperties} mapped to {columns}. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the conflicting values.
        /// </summary>
        public static string ConflictingOriginalRowValues([CanBeNull] object firstEntityType, [CanBeNull] object secondEntityType, [CanBeNull] object firstProperties, [CanBeNull] object secondProperties, [CanBeNull] object columns)
            => string.Format(
                GetString("ConflictingOriginalRowValues", nameof(firstEntityType), nameof(secondEntityType), nameof(firstProperties), nameof(secondProperties), nameof(columns)),
                firstEntityType, secondEntityType, firstProperties, secondProperties, columns);

        /// <summary>
        ///     The instance of entity type '{firstEntityType}' and the instance of entity type '{secondEntityType}' are mapped to the same row with the key value '{keyValue}', but have different original property values '{firstConflictingValues}' and '{secondConflictingValues}' mapped to {columns}.
        /// </summary>
        public static string ConflictingOriginalRowValuesSensitive([CanBeNull] object firstEntityType, [CanBeNull] object secondEntityType, [CanBeNull] object keyValue, [CanBeNull] object firstConflictingValues, [CanBeNull] object secondConflictingValues, [CanBeNull] object columns)
            => string.Format(
                GetString("ConflictingOriginalRowValuesSensitive", nameof(firstEntityType), nameof(secondEntityType), nameof(keyValue), nameof(firstConflictingValues), nameof(secondConflictingValues), nameof(columns)),
                firstEntityType, secondEntityType, keyValue, firstConflictingValues, secondConflictingValues, columns);

        /// <summary>
        ///     The entity of '{entityType}' is sharing the table '{tableName}' with '{missingEntityType}', but there is no entity of this type with the same key value that has been marked as '{state}'. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the key values.
        /// </summary>
        public static string SharedRowEntryCountMismatch([CanBeNull] object entityType, [CanBeNull] object tableName, [CanBeNull] object missingEntityType, [CanBeNull] object state)
            => string.Format(
                GetString("SharedRowEntryCountMismatch", nameof(entityType), nameof(tableName), nameof(missingEntityType), nameof(state)),
                entityType, tableName, missingEntityType, state);

        /// <summary>
        ///     The entity of '{entityType}' is sharing the table '{tableName}' with '{missingEntityType}', but there is no entity of this type with the same key value '{keyValue}' that has been marked as '{state}'.
        /// </summary>
        public static string SharedRowEntryCountMismatchSensitive([CanBeNull] object entityType, [CanBeNull] object tableName, [CanBeNull] object missingEntityType, [CanBeNull] object keyValue, [CanBeNull] object state)
            => string.Format(
                GetString("SharedRowEntryCountMismatchSensitive", nameof(entityType), nameof(tableName), nameof(missingEntityType), nameof(keyValue), nameof(state)),
                entityType, tableName, missingEntityType, keyValue, state);

        /// <summary>
        ///     Cannot set default value '{value}' of type '{valueType}' on property '{property}' of type '{propertyType}' in entity type '{entityType}'.
        /// </summary>
        public static string IncorrectDefaultValueType([CanBeNull] object value, [CanBeNull] object valueType, [CanBeNull] object property, [CanBeNull] object propertyType, [CanBeNull] object entityType)
            => string.Format(
                GetString("IncorrectDefaultValueType", nameof(value), nameof(valueType), nameof(property), nameof(propertyType), nameof(entityType)),
                value, valueType, property, propertyType, entityType);

        /// <summary>
        ///     The discriminator value for '{entityType1}' is '{discriminatorValue}' which is the same for '{entityType2}'. Every concrete entity type in the hierarchy needs to have a unique discriminator value.
        /// </summary>
        public static string DuplicateDiscriminatorValue([CanBeNull] object entityType1, [CanBeNull] object discriminatorValue, [CanBeNull] object entityType2)
            => string.Format(
                GetString("DuplicateDiscriminatorValue", nameof(entityType1), nameof(discriminatorValue), nameof(entityType2)),
                entityType1, discriminatorValue, entityType2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured with different nullability.
        /// </summary>
        public static string DuplicateColumnNameNullabilityMismatch([CanBeNull] object entityType1, [CanBeNull] object property1, [CanBeNull] object entityType2, [CanBeNull] object property2, [CanBeNull] object columnName, [CanBeNull] object table)
            => string.Format(
                GetString("DuplicateColumnNameNullabilityMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table)),
                entityType1, property1, entityType2, property2, columnName, table);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured to use different computed values ('{value1}' and '{value2}').
        /// </summary>
        public static string DuplicateColumnNameComputedSqlMismatch([CanBeNull] object entityType1, [CanBeNull] object property1, [CanBeNull] object entityType2, [CanBeNull] object property2, [CanBeNull] object columnName, [CanBeNull] object table, [CanBeNull] object value1, [CanBeNull] object value2)
            => string.Format(
                GetString("DuplicateColumnNameComputedSqlMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(value1), nameof(value2)),
                entityType1, property1, entityType2, property2, columnName, table, value1, value2);

        /// <summary>
        ///     '{entityType1}.{property1}' and '{entityType2}.{property2}' are both mapped to column '{columnName}' in '{table}' but are configured to use different default values ('{value1}' and '{value2}').
        /// </summary>
        public static string DuplicateColumnNameDefaultSqlMismatch([CanBeNull] object entityType1, [CanBeNull] object property1, [CanBeNull] object entityType2, [CanBeNull] object property2, [CanBeNull] object columnName, [CanBeNull] object table, [CanBeNull] object value1, [CanBeNull] object value2)
            => string.Format(
                GetString("DuplicateColumnNameDefaultSqlMismatch", nameof(entityType1), nameof(property1), nameof(entityType2), nameof(property2), nameof(columnName), nameof(table), nameof(value1), nameof(value2)),
                entityType1, property1, entityType2, property2, columnName, table, value1, value2);

        /// <summary>
        ///     {conflictingConfiguration} cannot be set for '{property}', because {existingConfiguration} is already set.
        /// </summary>
        public static string ConflictingColumnServerGeneration([CanBeNull] object conflictingConfiguration, [CanBeNull] object property, [CanBeNull] object existingConfiguration)
            => string.Format(
                GetString("ConflictingColumnServerGeneration", nameof(conflictingConfiguration), nameof(property), nameof(existingConfiguration)),
                conflictingConfiguration, property, existingConfiguration);

        /// <summary>
        ///     The foreign keys {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}' but use different columns ({columnNames1} and {columnNames2}).
        /// </summary>
        public static string DuplicateForeignKeyColumnMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object foreignKeyName, [CanBeNull] object columnNames1, [CanBeNull] object columnNames2)
            => string.Format(
                GetString("DuplicateForeignKeyColumnMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(columnNames1), nameof(columnNames2)),
                index1, entityType1, index2, entityType2, table, foreignKeyName, columnNames1, columnNames2);

        /// <summary>
        ///     The foreign keys {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}' but with different delete behavior ('{deleteBehavior1}' and '{deleteBehavior2}').
        /// </summary>
        public static string DuplicateForeignKeyDeleteBehaviorMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object foreignKeyName, [CanBeNull] object deleteBehavior1, [CanBeNull] object deleteBehavior2)
            => string.Format(
                GetString("DuplicateForeignKeyDeleteBehaviorMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(deleteBehavior1), nameof(deleteBehavior2)),
                index1, entityType1, index2, entityType2, table, foreignKeyName, deleteBehavior1, deleteBehavior2);

        /// <summary>
        ///     The foreign keys {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}' but referencing different principal columns ({principalColumnNames1} and {principalColumnNames2}).
        /// </summary>
        public static string DuplicateForeignKeyPrincipalColumnMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object foreignKeyName, [CanBeNull] object principalColumnNames1, [CanBeNull] object principalColumnNames2)
            => string.Format(
                GetString("DuplicateForeignKeyPrincipalColumnMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(principalColumnNames1), nameof(principalColumnNames2)),
                index1, entityType1, index2, entityType2, table, foreignKeyName, principalColumnNames1, principalColumnNames2);

        /// <summary>
        ///     The foreign keys {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}' but referencing different principal tables ('{principalTable1}' and '{principalTable2}').
        /// </summary>
        public static string DuplicateForeignKeyPrincipalTableMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object foreignKeyName, [CanBeNull] object principalTable1, [CanBeNull] object principalTable2)
            => string.Format(
                GetString("DuplicateForeignKeyPrincipalTableMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(foreignKeyName), nameof(principalTable1), nameof(principalTable2)),
                index1, entityType1, index2, entityType2, table, foreignKeyName, principalTable1, principalTable2);

        /// <summary>
        ///     The foreign keys {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{foreignKeyName}' but with different uniqueness.
        /// </summary>
        public static string DuplicateForeignKeyUniquenessMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object foreignKeyName)
            => string.Format(
                GetString("DuplicateForeignKeyUniquenessMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(foreignKeyName)),
                index1, entityType1, index2, entityType2, table, foreignKeyName);

        /// <summary>
        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}' but with different columns ({columnNames1} and {columnNames2}).
        /// </summary>
        public static string DuplicateIndexColumnMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object indexName, [CanBeNull] object columnNames1, [CanBeNull] object columnNames2)
            => string.Format(
                GetString("DuplicateIndexColumnMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName), nameof(columnNames1), nameof(columnNames2)),
                index1, entityType1, index2, entityType2, table, indexName, columnNames1, columnNames2);

        /// <summary>
        ///     The indexes {index1} on '{entityType1}' and {index2} on '{entityType2}' are both mapped to '{table}.{indexName}' but with different uniqueness.
        /// </summary>
        public static string DuplicateIndexUniquenessMismatch([CanBeNull] object index1, [CanBeNull] object entityType1, [CanBeNull] object index2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object indexName)
            => string.Format(
                GetString("DuplicateIndexUniquenessMismatch", nameof(index1), nameof(entityType1), nameof(index2), nameof(entityType2), nameof(table), nameof(indexName)),
                index1, entityType1, index2, entityType2, table, indexName);

        /// <summary>
        ///     The keys {key1} on '{entityType1}' and {key2} on '{entityType2}' are both mapped to '{table}.{keyName}' but with different columns ({columnNames1} and {columnNames2}).
        /// </summary>
        public static string DuplicateKeyColumnMismatch([CanBeNull] object key1, [CanBeNull] object entityType1, [CanBeNull] object key2, [CanBeNull] object entityType2, [CanBeNull] object table, [CanBeNull] object keyName, [CanBeNull] object columnNames1, [CanBeNull] object columnNames2)
            => string.Format(
                GetString("DuplicateKeyColumnMismatch", nameof(key1), nameof(entityType1), nameof(key2), nameof(entityType2), nameof(table), nameof(keyName), nameof(columnNames1), nameof(columnNames2)),
                key1, entityType1, key2, entityType2, table, keyName, columnNames1, columnNames2);

        /// <summary>
        ///     No mapping to a relational type can be found for property '{entity}.{property}' with the CLR type '{clrType}'.
        /// </summary>
        public static string UnsupportedPropertyType([CanBeNull] object entity, [CanBeNull] object property, [CanBeNull] object clrType)
            => string.Format(
                GetString("UnsupportedPropertyType", nameof(entity), nameof(property), nameof(clrType)),
                entity, property, clrType);

        /// <summary>
        ///     Sequence contains no elements.
        /// </summary>
        public static string NoElements
            => GetString("NoElements");

        /// <summary>
        ///     An error occurred using the connection to database '{database}' on server '{server}'.
        /// </summary>
        public static readonly EventDefinition<string, string> LogRelationalLoggerConnectionErrorAsDebug
            = new EventDefinition<string, string>(
                RelationalEventId.ConnectionError,
                LogLevel.Debug,
                LoggerMessage.Define<string, string>(
                    LogLevel.Debug,
                    RelationalEventId.ConnectionError,
                    _resourceManager.GetString("LogRelationalLoggerConnectionErrorAsDebug")));

        /// <summary>
        ///     The DbFunction '{function}' has an invalid return type '{type}'. Ensure that the return type can be mapped by the current provider.
        /// </summary>
        public static string DbFunctionInvalidReturnType([CanBeNull] object function, [CanBeNull] object type)
            => string.Format(
                GetString("DbFunctionInvalidReturnType", nameof(function), nameof(type)),
                function, type);

        /// <summary>
        ///     The DbFunction '{function}' has no name set. Name is a required property of a DbFunction.
        /// </summary>
        public static string DbFunctionNameEmpty([CanBeNull] object function)
            => string.Format(
                GetString("DbFunctionNameEmpty", nameof(function)),
                function);

        /// <summary>
        ///     The parameter '{parameter}' for the DbFunction '{function}' has an invalid type '{type}'. Ensure the parameter type can be mapped by the current provider.
        /// </summary>
        public static string DbFunctionInvalidParameterType([CanBeNull] object parameter, [CanBeNull] object function, [CanBeNull] object type)
            => string.Format(
                GetString("DbFunctionInvalidParameterType", nameof(parameter), nameof(function), nameof(type)),
                parameter, function, type);

        /// <summary>
        ///     The DbFunction '{function}' must be a static method. Non-static methods are not supported.
        /// </summary>
        public static string DbFunctionMethodMustBeStatic([CanBeNull] object function)
            => string.Format(
                GetString("DbFunctionMethodMustBeStatic", nameof(function)),
                function);

        /// <summary>
        ///     The DbFunction '{function}' is generic. Generic methods are not supported.
        /// </summary>
        public static string DbFunctionGenericMethodNotSupported([CanBeNull] object function)
            => string.Format(
                GetString("DbFunctionGenericMethodNotSupported", nameof(function)),
                function);

        /// <summary>
        ///     The provided DbFunction expression '{expression}' is invalid. The expression should be a lambda expression containing a single method call to the target static method. Default values can be provided as arguments if required. E.g. () =&gt; SomeClass.SomeMethod(null, 0)
        /// </summary>
        public static string DbFunctionExpressionIsNotMethodCall([CanBeNull] object expression)
            => string.Format(
                GetString("DbFunctionExpressionIsNotMethodCall", nameof(expression)),
                expression);

        private static string GetString(string name, params string[] formatterNames)
        {
            var value = _resourceManager.GetString(name);
            for (var i = 0; i < formatterNames.Length; i++)
            {
                value = value.Replace("{" + formatterNames[i] + "}", "{" + i + "}");
            }

            return value;
        }
    }
}
